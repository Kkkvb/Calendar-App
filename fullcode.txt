package zhang.myapplication

import android.Manifest
import android.annotation.SuppressLint
import android.app.TimePickerDialog
import android.content.Intent
import android.os.Build
import android.os.Bundle
import android.provider.Settings
import android.view.Menu
import android.view.MenuItem
import android.widget.ArrayAdapter
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.appcompat.widget.Toolbar
import androidx.core.view.isVisible
import androidx.drawerlayout.widget.DrawerLayout
import androidx.lifecycle.lifecycleScope
import androidx.navigation.findNavController
import androidx.navigation.fragment.NavHostFragment
import androidx.navigation.ui.AppBarConfiguration
import androidx.navigation.ui.navigateUp
import androidx.navigation.ui.setupActionBarWithNavController
import androidx.navigation.ui.setupWithNavController
import com.google.android.material.bottomnavigation.BottomNavigationView
import com.google.android.material.navigation.NavigationView
import kotlinx.coroutines.launch
import zhang.myapplication.data.Course
import zhang.myapplication.data.WeekFilter
import zhang.myapplication.databinding.ActivityMainBinding
import zhang.myapplication.databinding.DialogAddCourseBinding
import zhang.myapplication.domain.ReminderScheduler
import java.time.DayOfWeek
import java.time.LocalDate
import java.time.LocalTime
import java.time.temporal.TemporalAdjusters

class MainActivity : AppCompatActivity() {

    private lateinit var binding: ActivityMainBinding
    private lateinit var appBarConfiguration: AppBarConfiguration

    // Ask for notifications on Android 13+ when app starts
    private val requestNotifPermission = registerForActivityResult(
        ActivityResultContracts.RequestPermission()
    ) { /* no-op */ }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        // --- Optional toolbar hookup (only if your layout has @id/toolbar) ---
        val toolbar: Toolbar? = binding.root.findViewById(R.id.toolbar)
        toolbar?.let { setSupportActionBar(it) }

        // --- NavController / host ---
        val navHost = supportFragmentManager
            .findFragmentById(R.id.nav_host_fragment_activity_main) as NavHostFragment
        val navController = navHost.navController

        // --- Bottom navigation (Home/Dashboard/Notifications) ---
        val bottomNav: BottomNavigationView = binding.navView
        bottomNav.setupWithNavController(navController)

        // --- DrawerLayout & Side Navigation (Settings etc.) ---
        val drawerLayout: DrawerLayout? = binding.root.findViewById(R.id.drawer_layout)
        val sideNav: NavigationView? = findViewById(R.id.nav_view_side)
        sideNav?.setupWithNavController(navController)
        sideNav?.setNavigationItemSelectedListener { menuItem ->
            when (menuItem.itemId) {
                R.id.nav_settings -> {
                    // navigate via global action to SettingsFragment
                    findNavController(R.id.nav_host_fragment_activity_main)
                        .navigate(R.id.action_global_settingsFragment)
                    drawerLayout?.closeDrawers()
                    true
                }

                else -> false
            }
        }

        // --- AppBarConfiguration with Drawer: shows hamburger on top-level destinations ---
        appBarConfiguration = AppBarConfiguration(
            setOf(
                R.id.navigation_home,
                R.id.navigation_dashboard,
                R.id.navigation_notifications
            ),
            drawerLayout // hook the drawer so hamburger appears
        )
        setupActionBarWithNavController(navController, appBarConfiguration)

        // Hide bottom nav when NOT at a top-level destination (e.g., Settings)
        navController.addOnDestinationChangedListener { _, dest, _ ->
            val isTopLevel = dest.id in setOf(
                R.id.navigation_home,
                R.id.navigation_dashboard,
                R.id.navigation_notifications
            )
            binding.navView.isVisible = isTopLevel
        }

        // === Access singletons from ScheduleApp if needed ===
        val app = application as ScheduleApp

        // === Runtime permissions ===
        if (Build.VERSION.SDK_INT >= 33) {
            requestNotifPermission.launch(Manifest.permission.POST_NOTIFICATIONS)
        }
        // Exact alarms (Android 12+): open settings if not allowed
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            if (!app.alarmManager.canScheduleExactAlarms()) {
                startActivity(
                    Intent(Settings.ACTION_REQUEST_SCHEDULE_EXACT_ALARM)
                        .setData(android.net.Uri.parse("package:$packageName"))
                )
            }
        }
    }

    // Hamburger / Up support
    override fun onSupportNavigateUp(): Boolean {
        val navController = findNavController(R.id.nav_host_fragment_activity_main)
        return navController.navigateUp(appBarConfiguration) || super.onSupportNavigateUp()
    }

    // ----- Options menu (Add Course) -----
    override fun onCreateOptionsMenu(menu: Menu): Boolean {
        menuInflater.inflate(R.menu.main_actions, menu)
        return true
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        return when (item.itemId) {
            R.id.action_add_course -> {
                showAddCourseDialog()
                true
            }

            else -> super.onOptionsItemSelected(item)
        }
    }

    // ----- Add Course dialog (kept from your implementation) -----
    @SuppressLint("SetTextI18n")
    fun showAddCourseDialog() {
        val app = application as ScheduleApp
        val dao = app.db.courseDao()
        val scheduler = ReminderScheduler(this, app.alarmManager)
        val b = DialogAddCourseBinding.inflate(layoutInflater)

        // Day spinner
        val days = resources.getStringArray(R.array.days_of_week).toList()
        b.spDay.adapter = ArrayAdapter(this, android.R.layout.simple_spinner_dropdown_item, days)

        var startTime: LocalTime? = null
        var endTime: LocalTime? = null

        b.btnStartTime.setOnClickListener {
            val now = LocalTime.now()
            TimePickerDialog(this, { _, h, m ->
                startTime = LocalTime.of(h, m)
                b.btnStartTime.text = "Start: %02d:%02d".format(h, m)
            }, now.hour, now.minute, true).show()
        }

        b.btnEndTime.setOnClickListener {
            val now = LocalTime.now().plusMinutes(50)
            TimePickerDialog(this, { _, h, m ->
                endTime = LocalTime.of(h, m)
                b.btnEndTime.text = "End: %02d:%02d".format(h, m)
            }, now.hour, now.minute, true).show()
        }

        androidx.appcompat.app.AlertDialog.Builder(this)
            .setTitle("Add course")
            .setView(b.root)
            .setNegativeButton("Cancel", null)
            .setPositiveButton("Save") { _, _ ->
                val title = b.etTitle.text.toString().trim()
                val location = b.etLocation.text.toString().trim().ifBlank { null }
                val reminderMin = b.etReminder.text.toString().toIntOrNull() ?: 10
                val dayIdx = b.spDay.selectedItemPosition // 0..6
                val dayOfWeek = DayOfWeek.of(((dayIdx + 1 - 1) % 7) + 1)

                val st = startTime ?: run {
                    Toast.makeText(this, "Pick a start time", Toast.LENGTH_SHORT)
                        .show(); return@setPositiveButton
                }
                val et = endTime ?: run {
                    Toast.makeText(this, "Pick an end time", Toast.LENGTH_SHORT)
                        .show(); return@setPositiveButton
                }
                if (title.isBlank()) {
                    Toast.makeText(this, "Please enter a title", Toast.LENGTH_SHORT)
                        .show(); return@setPositiveButton
                }
                if (!et.isAfter(st)) {
                    Toast.makeText(this, "End time must be after start time", Toast.LENGTH_SHORT)
                        .show(); return@setPositiveButton
                }

                val semesterStart = LocalDate.now()
                    .with(TemporalAdjusters.previousOrSame(DayOfWeek.MONDAY))

                lifecycleScope.launch {
                    val course = Course(
                        title = title,
                        location = location,
                        dayOfWeek = dayOfWeek,
                        startTime = st,
                        endTime = et,
                        semesterStart = semesterStart,
                        totalWeeks = 16,
                        weekFilter = WeekFilter.ALL,
                        includedWeeks = emptySet(),
                        reminderMinutesBefore = reminderMin
                    )
                    val id = dao.upsert(course)
                    val saved = course.copy(id = id)

                    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.S ||
                        app.alarmManager.canScheduleExactAlarms()
                    ) {
                        scheduler.cancel(saved)
                        scheduler.scheduleNext(saved)
                        Toast.makeText(this@MainActivity, "Saved & scheduled", Toast.LENGTH_SHORT)
                            .show()
                    } else {
                        Toast.makeText(
                            this@MainActivity,
                            "Saved. Enable exact alarms to schedule reminders.",
                            Toast.LENGTH_LONG
                        ).show()
                    }
                }
            }
            .show()
    }
}